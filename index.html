<!doctype html>
<html>
<head>
    <title>Socket.IO</title>
</head>
<body>
<style>
    body {
        overflow: hidden;
        margin: 0px;
        height: 1080px;
        width: 1920px;
    }
</style>
<script src="res/vendor/Socket.io.js"></script>
<script src="res/vendor/Phaser.js"></script>
<script type="module">
    import {Player} from './res/Player.js'
    import {Units} from './res/Units.js'
    import {Conversion} from './res/Conversion.js'
    import {Constants} from './res/Constants.js'
    import {GameMap} from './res/GameMap.js'
    import {Graphics} from './res/Graphics.js'
    import {Path} from './res/Path.js'
    import {Pointer} from './res/Pointer.js'

    let gameMap = new GameMap();
    let gameMap2 = new GameMap();
    let graphics;
    let text;
    let player = new Player();
    let coord;
    let add;
    let stages = 0;
    let path1, path2;
    let debug = false;
    let phaser;

    let world = {
        players:{
            current:player
        }
    };

    var phaserGame = new Phaser.Game({
        type: Phaser.AUTO,
        width: 1920,
        height: 1080,
        scene: {
            create: gameInit,
            update: gameLoop
        }
    });

    function gameInit() {
        phaser = this;
        graphics = phaser.add.graphics();
        text = phaser.add.text(40, 40, '');
        coord = phaser.add.text(40, 60);
        add = phaser.add;

        phaser.input.on('pointermove', pointermove);
        phaser.input.on('pointerdown', pointerdown);

    }

    function gameLoop() {

        graphics.clear();
        drawPointer();
        drawCollision();
        drawPlayer();
        drawPath();
    }

    function drawPointer(){
        if (Pointer.positionByHex.y >= 0 && Pointer.positionByHex.x >= 0) {
            let oddr = Conversion.pixel2Offset(Pointer.positionByHex);
            if (oddr.q < GameMap.getInstance().getSize().q && oddr.r < GameMap.getInstance().getSize().r) {

                graphics.lineStyle(3, 0xe83331);
                graphics.strokePoints(Graphics.hex_corners(Pointer.positionByHex, Constants.sizeHex, 6), true);
            }
        }
    }

    function drawCollision() {
        if(GameMap.getInstance().getHexes().length) {
            for (let r = 0; r < GameMap.getInstance().getHexes().length; r++) {
                for (let q = 0; q < GameMap.getInstance().getHexes()[0].length; q++) {
                    if (GameMap.getInstance().getHexes()[r][q].collision) {
                        graphics.lineStyle(3, 0xe83331);
                        graphics.strokePoints(Graphics.hex_corners(Conversion.hex_to_pixel(Units.Hex(r,q)), Constants.sizeHex, 6), true).fillStyle(0x00ff00);
                        graphics.fillPath();
                    }
                }
            }
        }
    }

    function drawPlayer(){
        graphics.lineStyle(3, 0xe83331);
        graphics.fillStyle(0x2a42ff);
        graphics.strokePoints(Graphics.hex_corners(Conversion.hex_to_pixel(world.players.current.getCoordinates()), Constants.sizeHex, 6), true);
        graphics.fillPath();
    }

    function drawPath() {
        if (Path.finalPath.length > 0)
            Path.finalPath.forEach((hex) => {
                graphics.lineStyle(3, 0xe83331);
                graphics.fillStyle(0x6600a5, 1);
                graphics.strokePoints(Graphics.hex_corners(Conversion.hex_to_pixel(Units.Hex(hex.r,hex.q)), {x:Constants.sizeHex.x/2,y:Constants.sizeHex.y/2}, 6), true);
                graphics.fillPath();
            });
    }

    function pointerdown(pointer) {
        let hex = Conversion.pixel2Offset({x: pointer.x, y: pointer.y});
        if (
            Pointer.positionByHex.y >= 0 &&
            Pointer.positionByHex.x >= 0 &&
            hex.q < GameMap.getInstance().getSize().q &&
            hex.r < GameMap.getInstance().getSize().r &&
            GameMap.getInstance().getHexes()[hex.r][hex.q].collision === false
        ) {
            switch (stages) {
                case 0:
                    path1 = hex;
                    stages = 1;
                    break;
                case 1:
                    path2 = hex;
                    debug = true;
                    Path.findPath(path1, path2);
                    stages = 2;
                    //console.log(time);
                    break;
                case 2:
                    debug = false;
                    Path.finalPath = [];
                    Path.finalPathNeighbors = [];
                    path1 = undefined;
                    path2 = undefined;
                    stages = 0;
                    break;
            }
            path2 = hex;
            Path.finalPath = Path.findPath(world.players.current.getCoordinates(), path2);
            Path.finalPath.shift();
            world.players.current.goByPath(Path.finalPath)

        }
    }

    function pointermove(pointer) {

        var cube = Conversion.pixel2Cube({x: pointer.x, y: pointer.y});
        var round_cube = Conversion.cubeRound(cube);
        var round_hex = Conversion.cube2Offset(round_cube);
        Pointer.positionByHex = Conversion.hex_to_pixel(round_hex);
        path2 = round_hex;

        var offsetToCube = Conversion.offset2Cube(round_hex);
        if (
            Pointer.positionByHex.y >= 0 &&
            Pointer.positionByHex.x >= 0 &&
            round_hex.q < GameMap.getInstance().getSize().q &&
            round_hex.r < GameMap.getInstance().getSize().r &&
            typeof path1 !== "undefined" &&
            stages === 1 &&
            GameMap.getInstance().getHexes()[round_hex.r][round_hex.q].collision === false
        ) {
            Path.findPath(path1, path2);
        }

        coord.text = 'Cursor\n x:' + pointer.x + "\n" + ' y:' + pointer.y + "\n" +
            'Hex\n r:' + round_hex.r + "\n" + ' q:' + round_hex.q + "\n" +
            'Cube\n x:' + round_cube.x + "\n" + ' y:' + round_cube.y + "\n" + ' z:' + round_cube.z + "\n"+
            'Offset2Cube\n x:' + offsetToCube.x + "\n" + ' y:' + offsetToCube.y + "\n" + ' z:' + offsetToCube.z + "\n";

    }


</script>
</body>
</html>
