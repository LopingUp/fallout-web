<!doctype html>
<html>
<head>
    <title>Socket.IO</title>
</head>
<body>
<style>
    body {
        overflow: hidden;
        margin: 0px;
        height: 1080px;
        width: 1920px;
    }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.2.0/socket.io.js"></script>
<script src="https://cdn.jsdelivr.net/npm/phaser@3.15.1/dist/phaser-arcade-physics.min.js"></script>
<script type="module">
    import {Player} from './res/Player.js'
    import {ArrayHelper} from './res/ArrayHelper.js'
    import {PriorityQueue} from './res/PriorityQueue.js'
    import {Units} from './res/Units.js'
    import {HexMath} from './res/HexMath.js'
    import {Conversion} from './res/Conversion.js'
    import {Constants} from './res/Constants.js'

    let mapSize = {q: 15, r: 22};
    let size = Constants.sizeHex;
    let center = {x: 0, y: 0};
    var graphics;
    var text;
    var player = new Player();
    var coord;
    let finalPath = [];
    var finalPathNeighbors = [];
    var add;
    var stages = 0;
    var path1, path2;
    let coordLock = null;
    var debug = false;
    var algo = 1;

    let world = {
        map:ArrayHelper.multiArray(mapSize.q, mapSize.r),
        players:{
            current:player,
            other:[
                {
                    coord:{
                        q:5,
                        r:5
                    }
                }
            ]
        }
    };

    //Fill Map Collision
    for (let q = 0; q < mapSize.q; q++) {
        for (let r = 0; r < mapSize.r; r++) {
            //map[q][r] = {collision: Math.random() >= 0.8};
            world.map[q][r] = {collision: false};
        }
    }

    world.map[3][2] = {collision: true};
    world.map[4][2] = {collision: true};
    world.map[5][2] = {collision: true};
    world.map[6][2] = {collision: true};
    world.map[7][2] = {collision: true};
    world.map[7][3] = {collision: true};
    world.map[7][4] = {collision: true};
    world.map[7][5] = {collision: true};
    world.map[7][6] = {collision: true};
    world.map[7][7] = {collision: true};
    world.map[7][8] = {collision: true};
    world.map[7][9] = {collision: true};
    world.map[7][10] = {collision: true};
    world.map[7][11] = {collision: true};
    world.map[7][12] = {collision: true};
    world.map[7][13] = {collision: true};
    world.map[7][14] = {collision: true};
    world.map[7][15] = {collision: true};
    world.map[7][16] = {collision: true};
    world.map[7][17] = {collision: true};
    world.map[7][18] = {collision: true};
    world.map[7][19] = {collision: true};
    world.map[7][20] = {collision: true};
    world.map[6][20] = {collision: true};
    world.map[5][20] = {collision: true};
    world.map[4][20] = {collision: true};
    world.map[3][20] = {collision: true};

    world.map[11][5] = {collision: true};

    const offsetDirections = [
        [
            [0, -1],[+1, 0],[0, +1],[-1, +1],[-1, 0],[-1, -1]
        ],
        [
            [+1, -1],[+1, 0],[+1, +1],[0, +1],[-1, 0],[0, -1]
        ],
    ];

    // const cubeDirections = [
    //     Units.Cube(+1, -1, 0), Units.Cube(+1, 0, -1), Units.Cube(0, +1, -1),
    //     Units.Cube(-1, +1, 0), Units.Cube(-1, 0, +1), Units.Cube(0, -1, +1)
    //   ];

    let offsetNeighbor = (hex, direction) => {
        var parity = hex.r & 1;
        var dir = offsetDirections[parity][direction];
        var hexf = Units.Hex(hex.q + dir[0], hex.r + dir[1]);
        return hexf
    };

    let getOffsetNeighbors = (hex) => {
        const neighbors = [];
        for (let i = 0; i < 6; i++) {
            const neighbor_offset = offsetNeighbor(hex, i);

            // Is the neighbor on/in the map?
            if (neighbor_offset.q >= 0 && neighbor_offset.r >= 0
                && neighbor_offset.q < mapSize.q && neighbor_offset.r < mapSize.r) {

                if (!world.map[neighbor_offset.q][neighbor_offset.r].collision) {
                    neighbors.push(neighbor_offset); // add an edge to the graph
                }
            }
        }
        return neighbors;
    };


    // cubeDirection = (d) => cubeDirections[d];
    //
    // cubeNeighbor = (h, d) => HexMath.cubeAdd(h, cubeDirection(d));
    //
    // cubeNeighbors = (h) => {
    //     const neighbors = [];
    //     for (let d = 0; d < 6; d++) {
    //       neighbors.push(cubeNeighbor(h, d));
    //     }
    //
    //     return neighbors;
    // };

    //get coord corner dot hex by count
    let hex_corners = (center, size, corners) => {

        var coords = [];
        for (let i = 1; i <= corners; i++) {
            var angle_deg = 60 * i - 30;
            var angle_rad = Math.PI / 180 * angle_deg;
            coords.push(Units.Point(center.x + size.x * Math.cos(angle_rad),
                center.y + size.y * Math.sin(angle_rad)));
        }
        return coords;
    };

    let findHexMap = (hex) => {
        //const hexOffset = Conversion.cube2Offset(hex);
        const hexOffset = hex;
        if (world.map[hexOffset.q]) {
            return world.map[hexOffset.q][hexOffset.r];
        } else {
            return undefined;
        }
    };

    // Generate data of Hexes, filling map array neighbors, coordinates, collision
    // initHexes = () => {
    //
    //   for (let q = 0; q < mapSize.q; q++) {
    //     for (let r = 0; r < mapSize.r; r++) {
    //
    //       const hex = Units.Hex(q, r),
    //         cube = Conversion.offset2Cube(hex);
    //       let neighbors = [];
    //
    //       if (!map[q][r].collision) {
    //
    //         neighbors = getOffsetNeighbors(hex);
    //       }
    //
    //       // fill things into cell
    //       map[q][r].cube = cube;
    //       map[q][r].hex = hex;
    //       map[q][r].neighbors = neighbors;
    //     }
    //   }
    // };

    //////////////////////////////////////////////////////////////////////////////
    // PATH FINDING
    // From:
    //	http://www.redblobgames.com/pathfinding/a-star/introduction.html
    //	http://www.redblobgames.com/pathfinding/a-star/implementation.html

    //get "to" hexes
    let getIndexHexes = (cames) => {
        const hexes = [];
        for (let h = 0; h < came.length; h++) {
            hexes.push(came[h].to);
        }
        return hexes;
    };

    //find hex from came to current hex
    let findFromHex = (cames, hex) => {
        for (let h = 0; h < cames.length; h++) {
            if (HexMath.hexEqual(cames[h].to, hex)) {
                return cames[h];
            }
        }
        return undefined;
    };
    /**
     *
     * @param {object} start
     * @param goal
     * @returns array
     */
    let findPath = (start, goal) => {
        // if(debug == true){
        //   debugger;
        // }
        finalPathNeighbors = [];
        //time = performance.now();
        const frontier = new PriorityQueue();  // List of the places to explore next
        const came = [];// List of where we've already been - "from" and The price we paid to go there - "cost"
        let found = false;

        frontier.push(start, 0);
        came.push({to: start, from: start, cost: 0});

        while (frontier.length() > 0) {

            const current = frontier.pop();
            //const currentHex = map[current.q][current.r];

            const neighbors = getOffsetNeighbors(current);

            // Early exit (stop exploring map when goal is reached)
            if (HexMath.hexEqual(current, goal)) {
                found = true;
                break;
            }

            for (let n = 0; n < neighbors.length; n++) {

                let next = neighbors[n],
                    newCost = (findFromHex(came, current).cost + 1);//, //plus one step
                //distance = HexMath.offsetDistance(goal, next);

                let eurist = newCost;// + distance;
                if (findFromHex(came, next) === undefined || newCost < findFromHex(came, next).cost) {
                    finalPathNeighbors.push([next, eurist]);
                    frontier.push(next, eurist);
                    came.push({to: next, from: current, cost: newCost});
                }
            }
        }

        // BUILD PATH BACK FROM GOAL
        if (goal && found) {
            let current = goal;
            let path = [goal];

            while (!HexMath.hexEqual(current, start)) {
                current = findFromHex(came, current).from;
                path.push(current);
            }
            //time = performance.now() - time;
            return path.reverse();

        } else {
            return undefined;
        }

    };

    //////////////////////////////////////////

    var game = new Phaser.Game({
        //type: Phaser.AUTO,
        type: Phaser.CANVAS,
        width: 1920,
        height: 1080,
        scene: {
            create: create,
            update: update
        }
    });

    function create() {

        //initHexes();
        graphics = this.add.graphics({lineStyle: {width: 3, color: 0xe83331}});
        text = this.add.text(40, 40, '');
        coord = this.add.text(40, 60);
        add = this.add;


        this.input.on('pointermove', pointermove);
        this.input.on('pointerdown', pointerdown);

        // for (let q = 0; q < mapSize.q; q++) {
        //   for (let r = 0; r < mapSize.r; r++) {
        //     let textPix = Conversion.hex_to_pixel(({q,r}));
        //
        //     world.map[q][r].text = this.add.text();
        //     world.map[q][r].text.coord = {x:textPix.x,y:textPix.y};
        //
        //     // world.map[q][r].text.text = q+':'+r;
        //     // world.map[q][r].text.x = map[q][r].text.coord.x-map[q][r].text.width/2;
        //     // world.map[q][r].text.y = map[q][r].text.coord.y-map[q][r].text.height/2;
        //
        //   }
        // }
    }

    function update() {

        //this.add.bitmapText({x:16, y:10, text:'Arial'});

        graphics.clear();
        if (center.y >= 0 && center.x >= 0) {
            let oddr = Conversion.pixel2Offset(center)
            if (oddr.q < mapSize.q && oddr.r < mapSize.r) {
                graphics.strokePoints(hex_corners(center, size, 6), true);
            }
        }
        if(world.map.length) {
            for (let q = 0; q < world.map.length; q++) {
                for (let r = 0; r < world.map[0].length; r++) {
                    //world.map[q][r].text.text = '';
                    try {
                        if (world.map[q][r].collision) {
                            graphics.strokePoints(hex_corners(Conversion.hex_to_pixel({
                                q: q,
                                r: r
                            }), size, 6), true).fillStyle(0x00ff00, 1).fillPath();
                        }
                    } catch (e) {
                        debugger;
                    }
                }
            }
        }
        graphics.strokePoints(hex_corners(Conversion.hex_to_pixel(world.players.current.getCoordinates()), size, 6), true).fillStyle(0x2a42ff, 1).fillPath();

        // if (finalPathNeighbors.length > 0){
        //   let min = arrayMin(finalPathNeighbors, 1);
        //   let max = arrayMax(finalPathNeighbors, 1);
        //   finalPathNeighbors.forEach((hex) => {
        //     let q =hex[0].q;
        //     let r = hex[0].r;
        //     let percentage = getPercentage(hex[1], min, max);
        //     graphics.strokePoints(hex_corners(Conversion.hex_to_pixel(({q,r})), size, 6), true).fillStyle("0x"+percentToHEXColor(percentage), 1).fillPath();
        //
        //
        //     //world.map[q][r].text.text = hex[1];
        //     //world.map[q][r].text.x = world.map[q][r].text.coord.x-world.map[q][r].text.width/2;
        //     //world.map[q][r].text.y = world.map[q][r].text.coord.y-world.map[q][r].text.height/2;
        //   });
        // }

        if (finalPath.length > 0)
            finalPath.forEach((hex) => {
                graphics.strokePoints(hex_corners(Conversion.hex_to_pixel({
                    q: hex.q,
                    r: hex.r
                }), {x:size.x/2,y:size.y/2}, 6), true).fillStyle(0x6600a5, 1).fillPath();
            });

    }
    let myTimeout;
    /**
     *
     * @param {array} path
     * @param {object} player
     */
    let goByPath = (path=[],player={})=>{
        myTimeout;
        let i = 0;
        i++;
        clearTimeout(myTimeout);

        pathIteration(i,path,player)
    }

    /**
     *
     * @param {number} i
     * @param {array} path
     * @param {object} player
     */
    let pathIteration = (i,path,player)=>{
        if(i++<path.length){
            myTimeout = setTimeout(()=>{
                player.coord = path[i-1];
                pathIteration(i,path,player);
            },300);
        }
        return i;
    };

    let pointerdown = pointer => {
        let hex = Conversion.pixel2Offset({x: pointer.x, y: pointer.y});
        if (
            center.y >= 0 &&
            center.x >= 0 &&
            hex.q < mapSize.q &&
            hex.r < mapSize.r &&
            world.map[hex.q][hex.r].collision === false
        ) {
            switch (stages) {
                case 0:
                    path1 = hex;
                    stages = 1;
                    break;
                case 1:
                    path2 = hex;
                    debug = true;
                    findPath(path1, path2);
                    stages = 2;
                    //console.log(time);
                    break;
                case 2:
                    debug = false;
                    finalPath = [];
                    finalPathNeighbors = [];
                    path1 = undefined;
                    path2 = undefined;
                    stages = 0;
                    break;
            }
            path2 = hex;
            finalPath = findPath(world.players.current.getCoordinates(), path2);
            finalPath.shift();
            world.players.current.goByPath(finalPath)

        }
    }

    let pointermove = pointer => {

        var cube = Conversion.pixel2Cube({x: pointer.x, y: pointer.y});
        var round_cube = Conversion.cubeRound(cube);
        var round_hex = Conversion.cube2Offset(round_cube);
        center = Conversion.hex_to_pixel(round_hex);
        path2 = round_hex;

        var offsetToCube = Conversion.offset2Cube(round_hex);
        if (
            center.y >= 0 &&
            center.x >= 0 &&
            round_hex.q < mapSize.q &&
            round_hex.r < mapSize.r &&
            typeof path1 !== "undefined" &&
            stages === 1 &&
            world.map[round_hex.q][round_hex.r].collision === false
        ) {
            findPath(path1,path2);
        }

        // let neghs = APuthSearch(round_hex, function (hex) {
        //   let oddr = pixel_to_oddr({x:game.config.width,y:game.config.height});
        //
        //   return hex.q < 0 || hex.r < 0 || hex.q > oddr.q+1 || hex.r > oddr.r+1
        //
        // });


        coord.text = 'Cursor\n x:' + pointer.x + "\n" + ' y:' + pointer.y + "\n" +
            'Hex\n r:' + round_hex.r + "\n" + ' q:' + round_hex.q + "\n" +
            'Cube\n x:' + round_cube.x + "\n" + ' y:' + round_cube.y + "\n" + ' z:' + round_cube.z + "\n"+
            'Offset2Cube\n x:' + offsetToCube.x + "\n" + ' y:' + offsetToCube.y + "\n" + ' z:' + offsetToCube.z + "\n";

    };


</script>
</body>
</html>
